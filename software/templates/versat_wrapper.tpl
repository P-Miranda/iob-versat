// File generated by template engine for the versat_wrapper.tpl template
// Do not make changes, versat will overwrite

#include <new>

#include <cstdint>
#include <cstdio>
#include <cassert>
#define Assert(x) assert(x)

#include "versat_accel.h" // TODO: Is this needed? We technically have all the data that we need to not depend on this header and removing this dependency could simplify the build process. Take a look later

#define ALIGN_UP(val,size) (((val) + (size - 1)) & ~(size - 1))
#define ALIGN_DOWN(val,size) (val & (~(size - 1)))

#include "verilated.h"

// Needed to obtain the wire size of the unit from the verilated code.
// Since the verilated code is an "instantiation" of the unit, we do not have to bother with the possibility of wire not being concrete (because they depend on parameters). We can just use the values directly.
#include "VUnitWireInfo.h"

@{defines}

@{memoryWireInfo}

inline void CopyFromMemory(void* output,void* memory,int address,int memoryDataSize){
   char* memoryAsChar = (char*) memory;
   int trueAddress = ALIGN_DOWN(address,memoryDataSize);

   // TODO: Check if we are not writing/reading outside the boundary
   //Assert(trueAddress <= );
   memcpy(output,&memoryAsChar[trueAddress],memoryDataSize);
};

inline void CopyToMemory(void* input,void* memory,int address,int memoryDataSize){
   char* memoryAsChar = (char*) memory;
   int trueAddress = ALIGN_DOWN(address,memoryDataSize);
   
   // TODO: Check if we are not writing/reading outside the boundary
   memcpy(&memoryAsChar[trueAddress],input,memoryDataSize);
}

#ifdef TRACE

VerilatedContext* contextp = new VerilatedContext;

#ifdef TRACE_FST
#include "verilated_fst_c.h"
static VerilatedFstC* tfp = NULL;
#else
#include "verilated_vcd_c.h"
static VerilatedVcdC* tfp = NULL;
#endif

#endif // TRACE

#include "V@{typeName}.h"
#ifdef SIMULATE_LOOPS
#include "VSuperAddress.h"
#endif

static V@{typeName}* dut = NULL;

extern VersatPrintf versatPrintf;
extern bool CreateVCD;
extern bool SimulateDatabus;

#define PRINT(...) if(versatPrintf){versatPrintf(__VA_ARGS__);}

// TODO: Maybe this should not exist. There should exist one update function and every other function that needs to update stuff should just call that function. UPDATE as it stands should only be called inside the update function. Instead of having macros that call UPDATE, we should just call the update function directly inside the RESET macro and the START_RUN macro and so one. Everything depends on the update function and the UPDATE macro is removed and replaced inside the function. The only problem is that I do not know if the RESET macro can call the update function without something. Nonetheless, every "update" should go trough the update function and none should go through this macro.
#ifdef TRACE
#define UPDATE(unit) \
   unit->clk = 0; \
   unit->eval(); \
   if(CreateVCD) tfp->dump(contextp->time()); \
   contextp->timeInc(2); \
   unit->clk = 1; \
   unit->eval();
#else
#define UPDATE(unit) \
   unit->clk = 0; \
   unit->eval(); \
   unit->clk = 1; \
   unit->eval();
#endif

static char* Bin(unsigned int value){
   static char buffer[33];
   buffer[32] = '\0';

   unsigned int val = value;
   for(int i = 31; i >= 0; i--){
      buffer[i] = '0' + (val & 0x1);
      val >>= 1;
   }

   return buffer;
}

struct DatabusAccess{
   int counter;
   int latencyCounter;
};

static const int INITIAL_MEMORY_LATENCY = 5;
static const int MEMORY_LATENCY = 0;

typedef char Byte;

// Everything is statically allocated

@{declareExternalMemory}

static AcceleratorConfig configBuffer = {};
static AcceleratorState stateBuffer = {};
static AcceleratorStatic staticBuffer = {};
static DatabusAccess databusBuffer[@{nIOs}] = {}; 

extern "C" void InitializeVerilator(){
#ifdef TRACE
  Verilated::traceEverOn(true);
#endif
}

extern "C" AcceleratorConfig* GetStartOfConfig(){
  return &configBuffer;
}

extern "C" AcceleratorState* GetStartOfState(){
  return &stateBuffer;
}

extern "C" AcceleratorStatic* GetStartOfStatic(){
  return &staticBuffer;
}

static void CloseWaveform(){
#ifdef TRACE
  if(CreateVCD && tfp){
    tfp->close();
  }
#endif
}

extern "C" void VersatAcceleratorCreate(){
#ifdef TRACE
   if(CreateVCD){
   #ifdef TRACE_FST
      tfp = new VerilatedFstC;
   #else
      tfp = new VerilatedVcdC;
   #endif
   }
#endif
   V@{typeName}* self = new V@{typeName}();

   if(dut){
      PRINT("Initialize function is being called multiple times\n");
      exit(-1);
   }

   dut = self;

#ifdef TRACE
  if(CreateVCD){
    self->trace(tfp, 99);
      
    #ifdef TRACE_FST
    tfp->open("system.fst");
    #else
    tfp->open("system.vcd");
    #endif

    atexit(CloseWaveform);
  }
#endif

  self->run = 0;
  self->clk = 0;
  self->rst = 0;
  self->running = 0;

@{inStart}

   self->rst = 1;
   UPDATE(self);
   self->rst = 0;

#ifdef TRACE
   if(CreateVCD) tfp->dump(contextp->time());
   contextp->timeInc(1);
   if(CreateVCD) tfp->dump(contextp->time());
   contextp->timeInc(1);
#endif
}

static int cyclesDone = 0;

static void InternalUpdateAccelerator(){
   int baseAddress = 0;

   cyclesDone += 1;

   int sizeOfData = (@{databusDataSize} / 8);

   V@{typeName}* self = dut;

   // Databus must be updated before memories because databus could drive memories but memories "cannot" drive databus (in the sense that databus acts like a master if connected directly to memories but memories do not act like a master when connected to a databus. The unit logic is the one that acts like a master)

@{databusSim}
   
   baseAddress = 0;

@{saveExternal}

   self->eval();
   UPDATE(self); // This line causes posedge clk events to activate
   
   // Memory Read
{
   baseAddress = 0;

@{memoryRead}

   self->eval();
}

// Memory write
{
  baseAddress = 0;

@{memoryWrite}

  self->eval();
}

#ifdef TRACE
   if(CreateVCD) tfp->dump(contextp->time());
   contextp->timeInc(2);
#endif

// TODO: Technically only need to do this at the end of an accelerator run, do not need to do this every single update
@{saveState}
}

static bool IsDone(){
   V@{typeName}* self = dut;
       
  return @{done};
}

struct Once{};
struct _OnceTag{};
template<typename F>
Once operator+(_OnceTag t,F&& f){
  f();
  return Once{};
}

#define TEMP__once(LINE) TEMPonce_ ## LINE
#define TEMP_once(LINE) TEMP__once( LINE )
#define once static Once TEMP_once(__LINE__) = _OnceTag() + [&]()

static void InternalStartAccelerator(){
  V@{typeName}* self = dut;

@{internalStart}

  self->run = 1;
  UPDATE(self);
  self->running = 1;
  self->run = 0;

#ifdef TRACE
  if(CreateVCD) tfp->dump(contextp->time());
  contextp->timeInc(1);
  if(CreateVCD) tfp->dump(contextp->time());
  contextp->timeInc(1);
#endif
}

static void InternalEndAccelerator(){
  V@{typeName}* self = dut;

  self->running = 0;

  // TODO: Is this update call needed?
  InternalUpdateAccelerator();

  // TODO: We could put the copy of state variables here
}

extern "C" int VersatAcceleratorCyclesElapsed(){
  return cyclesDone;
}

extern "C" void VersatAcceleratorSimulate(){
  InternalStartAccelerator();

  for(int i = 0; !IsDone() ; i++){
    InternalUpdateAccelerator();

    if(i >= 10000000){
      PRINT("Accelerator simulation has surpassed 10000000 cycles for a single run\n");
      PRINT("Assuming that the accelerator is stuck in a never ending loop\n");
      PRINT("Terminating simulation\n");
      fflush(stdout);
      exit(-1);
    }   
  }

  InternalEndAccelerator();
}

extern "C" int MemoryAccess(int address,int value,int write){
  V@{typeName}* self = dut;

@{memoryAccessDefines}

#ifdef HAS_MEMORY_MAP
  if(write){
    self->valid = 1;
    self->wstrb = 0xf;

    #ifdef MEMORY_MAP_BITS
      self->addr = address;
    #endif
      self->wdata = value;

      //while(!self->ready){ For now we assume all writes have no delay 
          InternalUpdateAccelerator();
      //}

      self->valid = 0;
      self->wstrb = 0x00;
    #ifdef MEMORY_MAP_BITS
      self->addr = 0x00000000;
    #endif
      self->wdata = 0x00000000;

      InternalUpdateAccelerator();
                
      return 0;
   } else {
      self->valid = 1;
      self->wstrb = 0x0;
    #ifdef MEMORY_MAP_BITS
      self->addr = address;
    #endif

      self->eval();

      while(!self->rvalid){
          InternalUpdateAccelerator();
      }

      int res = self->rdata;

      self->valid = 0;
    #ifdef MEMORY_MAP_BITS
      self->addr = 0;
    #endif

      self->eval();
      while(self->rvalid){
          InternalUpdateAccelerator();
      }

      return res;
   }
#endif
   return 0;
}

extern "C" void VersatSignalLoop(){
   V@{typeName}* self = dut;

#ifdef SIGNAL_LOOP
   self->signal_loop = 1;
   InternalUpdateAccelerator();
   self->signal_loop = 0;
   self->eval();
#endif
}

extern "C" void VersatLoadDelay(volatile const unsigned int* delayBuffer){
  V@{typeName}* self = dut;

@{setDelays}
}

iptr SimulateAddressPosition(iptr start_address,iptr amount_minus_one,iptr length,iptr addr_shift,int index){
  iptr address = start_address;
  iptr lengthAsTransfers = length / 4; // size of AXI_DATA_W;
  int current = index;

  PRINT("A: %p %ld %ld %ld %d\n",start_address,amount_minus_one,length,addr_shift,index);

  for(int i = 0; i < amount_minus_one + 1; i++){
     if(current < lengthAsTransfers){
       iptr actualAddress = (address + 4 * current);
       //PRINT("Return %p\n",actualAddress);
       return actualAddress;
     } else {
       address += addr_shift;
       current -= lengthAsTransfers;
     }
  }

  PRINT("SimulateAddressPosition reached a not possible state\n");
  return 0;
}

SimulateVReadResult SimulateVRead(AddressVArguments args){
   SimulateVReadResult result = {};

   result.amountOfExternalValuesRead = ((args.length) / sizeof(float)) * (args.amount_minus_one + 1);

   // TODO: Bitfield to save memory?
   bool* seen = (bool*) malloc(result.amountOfExternalValuesRead);
   memset(seen,false,result.amountOfExternalValuesRead);

   static VSuperAddress* self = nullptr;

   Verilated::traceEverOn(true);

   // Could also create and destroy everytime to make sure that we start fresh.
   if(self == nullptr){
      self = new VSuperAddress();
   }
   
   VerilatedVcdC* tfp = new VerilatedVcdC;
   self->trace(tfp, 99);
   tfp->open("simulate.vcd");

   bool doTrace = false;
   
#define DO_TRACE() self->eval(); \
   if(doTrace) {tfp->dump(contextp->time());} \
   contextp->timeInc(2);

#define UP() self->clk_i = 1; \
    DO_TRACE(); \
    self->clk_i = 0; \
    DO_TRACE();

   // These wires can always be set to these value.
   self->delay_i = 0;
   self->ignore_first_i = 0;
   self->data_ready_i = 1;
   self->data_valid_i = 1;
   self->reading = 1; // TODO: Does this make a difference? Also not like this existing in hardware either
   self->databus_ready = 1;
   self->ready_i = 1;

   self->run_i = 0;
   self->clk_i = 0;
   self->rst_i = 0;

   self->start_i = 0;
   self->duty_i = args.duty;
   self->period_i = args.per;
   self->incr_i = args.incr;
   self->iterations_i = args.iter;
   self->shift_i = args.shift;
   self->period2_i = args.per2;
   self->incr2_i = args.incr2;
   self->iterations2_i = args.iter2;
   self->shift2_i = args.shift2;
   self->period3_i = args.per3;
   self->incr3_i = args.incr3;
   self->iterations3_i = args.iter3;
   self->shift3_i = args.shift3;

   self->databus_length = 0;
   self->start_address_i = 0;
   self->address_shift_i = 0;
   self->count_i = 0;

   DO_TRACE();

   self->clk_i = 1;
   DO_TRACE();

   self->clk_i = 0;
   self->run_i = 1;

   DO_TRACE();

   self->clk_i = 1;
 
   DO_TRACE();

   self->run_i = 0;
   self->databus_last = 0;

   self->clk_i = 0;
   DO_TRACE();

   // Maybe waiting for the databus is not needed.
   int loops = 0;
   int arrayIndex = 0;
   while(!self->doneAddress){
      while(!self->valid_o){
          UP();
          loops += 1;
          if(loops > 10000){
            PRINT("Failed on A\n");
            goto end;
          }
      }
      
      if(self->store_o){
        iptr addr = self->addr_o / 4; // DATA_W 
        //PRINT("%d\n",addr);
        seen[addr] = true;
      }

      UP();
   }

end:

   UP();
   UP();
   UP();
   UP();
   UP();

   int amountSeen = 0;
   for(int i = 0; i < result.amountOfExternalValuesRead; i++){
      if(seen[i]){
         amountSeen += 1;
      }
   }

   free(seen);
   result.amountOfInternalValuesUsed = amountSeen;

   return result;
}

int SimulateAddressGen(iptr* arrayToFill,int arraySize,AddressVArguments args){
   static VSuperAddress* self = nullptr;

   Verilated::traceEverOn(true);

   // Could also create and destroy everytime to make sure that we start fresh.
   if(self == nullptr){
      self = new VSuperAddress();
   }
   
   VerilatedVcdC* tfp = new VerilatedVcdC;
   self->trace(tfp, 99);
   tfp->open("simulate.vcd");

   bool doTrace = false;
   
#define DO_TRACE() self->eval(); \
   if(doTrace) {tfp->dump(contextp->time());} \
   contextp->timeInc(2);

#define UP() self->clk_i = 1; \
    DO_TRACE(); \
    self->clk_i = 0; \
    DO_TRACE();

   // These wires can always be set to these value.
   self->delay_i = 0;
   self->ignore_first_i = 0;
   self->data_ready_i = 1;
   self->data_valid_i = 1;
   self->reading = 1; // TODO: Does this make a difference? Also not like this existing in hardware either
   self->databus_ready = 1;
   self->ready_i = 1;

   self->run_i = 0;
   self->clk_i = 0;
   self->rst_i = 0;

   self->start_i = 0;
   self->duty_i = args.duty;
   self->period_i = args.per;
   self->incr_i = args.incr;
   self->iterations_i = args.iter;
   self->shift_i = args.shift;
   self->period2_i = args.per2;
   self->incr2_i = args.incr2;
   self->iterations2_i = args.iter2;
   self->shift2_i = args.shift2;
   self->period3_i = args.per3;
   self->incr3_i = args.incr3;
   self->iterations3_i = args.iter3;
   self->shift3_i = args.shift3;

   self->databus_length = 0;
   self->start_address_i = 0;
   self->address_shift_i = 0;
   self->count_i = 0;

   DO_TRACE();

   self->clk_i = 1;
   DO_TRACE();

   self->clk_i = 0;
   self->run_i = 1;

   DO_TRACE();

   self->clk_i = 1;
 
   DO_TRACE();

   self->run_i = 0;
   self->databus_last = 0;

   self->clk_i = 0;
   DO_TRACE();

   // Maybe waiting for the databus is not needed.
   int loops = 0;
   int arrayIndex = 0;
   while(!self->doneAddress){
      while(!self->valid_o){
          UP();
          loops += 1;
          if(loops > 10000){
            PRINT("Failed on A\n");
            goto end;
          }
      }
      
      if(self->store_o){
        iptr addr = self->addr_o / 4; // DATA_W 
        if(arrayIndex < arraySize){
          arrayToFill[arrayIndex++] = SimulateAddressPosition(args.ext_addr,args.amount_minus_one,args.length,args.addr_shift,addr);
        }
      }

      UP();
   }

end:

   UP();
   UP();
   UP();
   UP();
   UP();

   return arrayIndex;
}

void SimulateAndPrintAddressGen(AddressVArguments args){
   static VSuperAddress* self = nullptr;

   Verilated::traceEverOn(true);

   // Could also create and destroy everytime to make sure that we start fresh.
   if(self == nullptr){
      self = new VSuperAddress();
   }
   
#ifdef TRACE_FST
   VerilatedFstC* tfp = new VerilatedFstC;
#else
   VerilatedVcdC* tfp = new VerilatedVcdC;
#endif

   self->trace(tfp, 99);
   tfp->open("simulate.vcd");

   bool doTrace = true;
   
#define DO_TRACE() self->eval(); \
   if(doTrace) {tfp->dump(contextp->time());} \
   contextp->timeInc(2);

#define UP() self->clk_i = 1; \
    DO_TRACE(); \
    self->clk_i = 0; \
    DO_TRACE();

   // These wires can always be set to these value.
   self->delay_i = 0;
   self->ignore_first_i = 0;
   self->data_ready_i = 1;
   self->data_valid_i = 1;
   self->reading = 1; // TODO: Does this make a difference? Also not like this existing in hardware either
   self->databus_ready = 1;
   self->ready_i = 1;

   self->run_i = 0;
   self->clk_i = 0;
   self->rst_i = 0;

   self->start_i = 0;
   self->duty_i = args.duty;
   self->period_i = args.per;
   self->incr_i = args.incr;
   self->iterations_i = args.iter;
   self->shift_i = args.shift;
   self->period2_i = args.per2;
   self->incr2_i = args.incr2;
   self->iterations2_i = args.iter2;
   self->shift2_i = args.shift2;
   self->period3_i = args.per3;
   self->incr3_i = args.incr3;
   self->iterations3_i = args.iter3;
   self->shift3_i = args.shift3;

   self->databus_length = 0;
   self->start_address_i = 0;
   self->address_shift_i = 0;
   self->count_i = 0;

   DO_TRACE();

   self->clk_i = 1;
   DO_TRACE();

   self->clk_i = 0;
   self->run_i = 1;

   DO_TRACE();

   self->clk_i = 1;
 
   DO_TRACE();

   self->run_i = 0;
   self->databus_last = 0;

   self->clk_i = 0;
   DO_TRACE();

   // Maybe waiting for the databus is not needed.
   int loops = 0;
   int totalIndex = 0;
   PRINT("LoopIndex : Index of position being accessed\n");
   while(!self->doneAddress){
      while(!self->valid_o){
          UP();
          loops += 1;
          if(loops > 10000){
            PRINT("Failed on A\n");
            goto end;
          }
      }
      
      if(self->store_o){
        iptr addr = self->addr_o / 4; // DATA_W 
        iptr address = SimulateAddressPosition(args.ext_addr,args.amount_minus_one,args.length,args.addr_shift,addr);

        PRINT("%d : %ld\n",totalIndex++,(address - args.ext_addr) / 4);
      }

      UP();
   }

end:

   UP();
   UP();
   UP();
   UP();
   UP();

   tfp->close();
}


#undef UPDATE

