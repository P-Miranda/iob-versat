// File generated by template engine for the versat_wrapper.tpl template
// Do not make changes, versat will overwrite

#include <new>

#include <cstdint>
#include <cstdio>
#include <cassert>
#define Assert(x) assert(x)

#include "versat_accel.h" // TODO: Is this needed? We technically have all the data that we need to not depend on this header and removing this dependency could simplify the build process. Take a look later

#define ALIGN_UP(val,size) (((val) + (size - 1)) & ~(size - 1))
#define ALIGN_DOWN(val,size) (val & (~(size - 1)))

#include "verilated.h"

// Needed to obtain the wire size of the unit from the verilated code.
// Since the verilated code is an "instantiation" of the unit, we do not have to bother with the possibility of wire not being concrete (because they depend on parameters). We can just use the values directly.
#include "VUnitWireInfo.h"
#include "pcEmulDefs.h"

@{defines}

@{memoryWireInfo}

inline void CopyFromMemory(void* output,void* memory,int address,int memoryDataSize){
   char* memoryAsChar = (char*) memory;
   int trueAddress = ALIGN_DOWN(address,memoryDataSize);

   // TODO: Check if we are not writing/reading outside the boundary
   //Assert(trueAddress <= );
   memcpy(output,&memoryAsChar[trueAddress],memoryDataSize);
};

inline void CopyToMemory(void* input,void* memory,int address,int memoryDataSize){
   char* memoryAsChar = (char*) memory;
   int trueAddress = ALIGN_DOWN(address,memoryDataSize);
   
   // TODO: Check if we are not writing/reading outside the boundary
   memcpy(&memoryAsChar[trueAddress],input,memoryDataSize);
}

#ifdef TRACE

VerilatedContext* contextp = new VerilatedContext;

#ifdef TRACE_FST
#include "verilated_fst_c.h"
static VerilatedFstC* tfp = NULL;
#else
#include "verilated_vcd_c.h"
static VerilatedVcdC* tfp = NULL;
#endif

#endif // TRACE

#include "V@{typeName}.h"
#ifdef SIMULATE_LOOPS
#include "VSuperAddress.h"
#endif

template<typename T>
class ArrayIterator{
public:
   T* ptr;

   inline bool operator!=(const ArrayIterator<T>& iter){return ptr != iter.ptr;};
   inline ArrayIterator<T>& operator++(){++ptr; return *this;};
   inline T& operator*(){return *ptr;};
};

template<typename T>
struct Array{
  T* data;
  int size;

  inline T& operator[](int index) const {Assert(index >= 0);Assert(index < size); return data[index];}
  ArrayIterator<T> begin() const{return ArrayIterator<T>{data};};
  ArrayIterator<T> end() const{return ArrayIterator<T>{data + size};};
};

struct DatabusAccess{
   int counter;
   int latencyCounter;
};

// ============================================================================
// Global data 

static V@{typeName}* dut = NULL;

VersatPrintf versatPrintf;
bool CreateVCD;
bool SimulateDatabus;
bool versatInitialized;

static @{typeName}Config configBuffer = {};
static @{typeName}State stateBuffer = {};
static AcceleratorStatic staticBuffer = {};
static DatabusAccess databusBuffer[@{nIOs}] = {}; 

volatile @{typeName}Config* accelConfig = (volatile @{typeName}Config*) &configBuffer;
volatile @{typeName}State* accelState = (volatile @{typeName}State*) &stateBuffer;
volatile AcceleratorStatic* accelStatic = (volatile AcceleratorStatic*) &staticBuffer;

// ============================================================================
// Utilities

#define PRINT(...) if(versatPrintf){versatPrintf(__VA_ARGS__);}

// TODO: Maybe this should not exist. There should exist one update function and every other function that needs to update stuff should just call that function. UPDATE as it stands should only be called inside the update function. Instead of having macros that call UPDATE, we should just call the update function directly inside the RESET macro and the START_RUN macro and so one. Everything depends on the update function and the UPDATE macro is removed and replaced inside the function. The only problem is that I do not know if the RESET macro can call the update function without something. Nonetheless, every "update" should go trough the update function and none should go through this macro.
#ifdef TRACE
#define UPDATE(unit) \
   unit->clk = 0; \
   unit->eval(); \
   if(CreateVCD) tfp->dump(contextp->time()); \
   contextp->timeInc(2); \
   unit->clk = 1; \
   unit->eval();
#else
#define UPDATE(unit) \
   unit->clk = 0; \
   unit->eval(); \
   unit->clk = 1; \
   unit->eval();
#endif

static char* Bin(unsigned int value){
   static char buffer[33];
   buffer[32] = '\0';

   unsigned int val = value;
   for(int i = 31; i >= 0; i--){
      buffer[i] = '0' + (val & 0x1);
      val >>= 1;
   }

   return buffer;
}

static const int INITIAL_MEMORY_LATENCY = 5;
static const int MEMORY_LATENCY = 0;

typedef char Byte;

// Everything is statically allocated

@{declareExternalMemory}

extern "C" void InitializeVerilator(){
#ifdef TRACE
  Verilated::traceEverOn(true);
#endif
}

static void CloseWaveform(){
#ifdef TRACE
  if(CreateVCD && tfp){
    tfp->close();
  }
#endif
}

static void FillMemoryWithGarbage(){
  // Need to select a value that is not likely to appear and that the user can quickly identify as a "garbage" value.
  int unlikelyValue = 0xBA;
  memset(externalMemory,unlikelyValue,totalExternalMemory);
}

extern "C" void VersatAcceleratorCreate(){
#ifdef TRACE
   if(CreateVCD){
   #ifdef TRACE_FST
      tfp = new VerilatedFstC;
   #else
      tfp = new VerilatedVcdC;
   #endif
   }
#endif
   V@{typeName}* self = new V@{typeName}();

   if(dut){
      PRINT("Initialize function is being called multiple times\n");
      exit(-1);
   }

   // In order to properly test memories, we fill them with a value different than zero. 
   FillMemoryWithGarbage();

   dut = self;

#ifdef TRACE
  if(CreateVCD){
    self->trace(tfp, 99);
      
    #ifdef TRACE_FST
    tfp->open("system.fst");
    #else
    tfp->open("system.vcd");
    #endif

    atexit(CloseWaveform);
  }
#endif

  self->run = 0;
  self->clk = 0;
  self->rst = 0;
  self->running = 0;

@{inStart}

   self->rst = 1;
   UPDATE(self);
   self->rst = 0;

#ifdef TRACE
   if(CreateVCD) tfp->dump(contextp->time());
   contextp->timeInc(1);
   if(CreateVCD) tfp->dump(contextp->time());
   contextp->timeInc(1);
#endif
}

static int cyclesDone = 0;

static void InternalUpdateAccelerator(){
   int baseAddress = 0;

   cyclesDone += 1;

   int sizeOfData = (@{databusDataSize} / 8);

   V@{typeName}* self = dut;

   // Databus must be updated before memories because databus could drive memories but memories "cannot" drive databus (in the sense that databus acts like a master if connected directly to memories but memories do not act like a master when connected to a databus. The unit logic is the one that acts like a master)

@{databusSim}
   
   baseAddress = 0;

@{saveExternal}

   self->eval();
   UPDATE(self); // This line causes posedge clk events to activate
   
   // Memory Read
{
   baseAddress = 0;

@{memoryRead}

   self->eval();
}

// Memory write
{
  baseAddress = 0;

@{memoryWrite}

  self->eval();
}

#ifdef TRACE
   if(CreateVCD) tfp->dump(contextp->time());
   contextp->timeInc(2);
#endif

// TODO: Technically only need to do this at the end of an accelerator run, do not need to do this every single update
@{saveState}
}

static bool IsDone(){
   V@{typeName}* self = dut;
       
  return @{done};
}

struct Once{};
struct _OnceTag{};
template<typename F>
Once operator+(_OnceTag t,F&& f){
  f();
  return Once{};
}

#define TEMP__once(LINE) TEMPonce_ ## LINE
#define TEMP_once(LINE) TEMP__once( LINE )
#define once static Once TEMP_once(__LINE__) = _OnceTag() + [&]()

@{declareExtraConfigs}

extern "C" void VersatReset(){
  FillMemoryWithGarbage();
  @{resetExtraConfigs}
}

static void InternalStartAccelerator(){
  V@{typeName}* self = dut;

@{internalStart}

  self->run = 1;
  UPDATE(self);
  self->running = 1;
  self->run = 0;

#ifdef TRACE
  if(CreateVCD) tfp->dump(contextp->time());
  contextp->timeInc(1);
  if(CreateVCD) tfp->dump(contextp->time());
  contextp->timeInc(1);
#endif
}

static void InternalEndAccelerator(){
  V@{typeName}* self = dut;

  self->running = 0;

  // TODO: Is this update call needed?
  InternalUpdateAccelerator();

  // TODO: We could put the copy of state variables here
}

extern "C" int VersatAcceleratorCyclesElapsed(){
  return cyclesDone;
}

void SimulateVUnits();

extern "C" void VersatAcceleratorSimulate(){
  InternalStartAccelerator();

  if(debugging){
    SimulateVUnits();
  }

  for(int i = 0; !IsDone() ; i++){
    InternalUpdateAccelerator();

    if(i >= 10000000){
      PRINT("Accelerator simulation has surpassed 10000000 cycles for a single run\n");
      PRINT("Assuming that the accelerator is stuck in a never ending loop\n");
      PRINT("Terminating simulation\n");
      fflush(stdout);
      exit(-1);
    }   
  }

  InternalEndAccelerator();
}

extern "C" int MemoryAccess(int address,int value,int write){
  V@{typeName}* self = dut;

@{memoryAccessDefines}

#ifdef HAS_MEMORY_MAP
  if(write){
    self->valid = 1;
    self->wstrb = 0xf;

    #ifdef MEMORY_MAP_BITS
      self->addr = address;
    #endif
      self->wdata = value;

      //while(!self->ready){ For now we assume all writes have no delay 
          InternalUpdateAccelerator();
      //}

      self->valid = 0;
      self->wstrb = 0x00;
    #ifdef MEMORY_MAP_BITS
      self->addr = 0x00000000;
    #endif
      self->wdata = 0x00000000;

      InternalUpdateAccelerator();
                
      return 0;
   } else {
      self->valid = 1;
      self->wstrb = 0x0;
    #ifdef MEMORY_MAP_BITS
      self->addr = address;
    #endif

      self->eval();

      while(!self->rvalid){
          InternalUpdateAccelerator();
      }

      int res = self->rdata;

      self->valid = 0;
    #ifdef MEMORY_MAP_BITS
      self->addr = 0;
    #endif

      self->eval();
      while(self->rvalid){
          InternalUpdateAccelerator();
      }

      return res;
   }
#endif
   return 0;
}

extern "C" void VersatSignalLoop(){
   V@{typeName}* self = dut;

#ifdef SIGNAL_LOOP
   self->signal_loop = 1;
   InternalUpdateAccelerator();
   self->signal_loop = 0;
   self->eval();
#endif
}

extern "C" void VersatLoadDelay(volatile const unsigned int* delayBuffer){
  V@{typeName}* self = dut;

@{setDelays}
}

iptr SimulateAddressPosition(iptr start_address,iptr amount_minus_one,iptr length,iptr addr_shift,int index){
  iptr address = start_address;
  iptr lengthAsTransfers = length / 4; // size of AXI_DATA_W;
  int current = index;

  //PRINT("A: %p %ld %ld %ld %d\n",start_address,amount_minus_one,length,addr_shift,index);

  for(int i = 0; i < amount_minus_one + 1; i++){
     if(current < lengthAsTransfers){
       iptr actualAddress = (address + 4 * current);
       return actualAddress;
     } else {
       address += addr_shift;
       current -= lengthAsTransfers;
     }
  }

  PRINT("SimulateAddressPosition reached a not possible state\n");
  return 0;
}

SimulateVReadResult SimulateVRead(AddressVArguments args){
   SimulateVReadResult result = {};

   result.amountOfExternalValuesRead = ((args.length) / sizeof(float)) * (args.amount_minus_one + 1);

   // TODO: Bitfield to save memory?
   bool* seen = (bool*) malloc(result.amountOfExternalValuesRead);
   memset(seen,false,result.amountOfExternalValuesRead);

   static VSuperAddress* self = nullptr;

   Verilated::traceEverOn(true);

   // Could also create and destroy everytime to make sure that we start fresh.
   if(self == nullptr){
      self = new VSuperAddress();
   }
   
   VerilatedVcdC* tfp = new VerilatedVcdC;
   self->trace(tfp, 99);
   tfp->open("simulate.vcd");

   bool doTrace = false;
   
#define DO_TRACE() self->eval(); \
   if(doTrace) {tfp->dump(contextp->time());} \
   contextp->timeInc(2);

#define UP() self->clk_i = 1; \
    DO_TRACE(); \
    self->clk_i = 0; \
    DO_TRACE();

   // These wires can always be set to these value.
   self->delay_i = 0;
   self->ignore_first_i = 0;
   self->data_ready_i = 1;
   self->data_valid_i = 1;
   self->reading = 1; // TODO: Does this make a difference? Also not like this existing in hardware either
   self->databus_ready = 1;
   self->ready_i = 1;

   self->run_i = 0;
   self->clk_i = 0;
   self->rst_i = 0;

   self->start_i = 0;
   self->duty_i = args.duty;
   self->per_i = args.per;
   self->incr_i = args.incr;
   self->iter_i = args.iter;
   self->shift_i = args.shift;
   self->per2_i = args.per2;
   self->incr2_i = args.incr2;
   self->iter2_i = args.iter2;
   self->shift2_i = args.shift2;
   self->per3_i = args.per3;
   self->incr3_i = args.incr3;
   self->iter3_i = args.iter3;
   self->shift3_i = args.shift3;

   self->databus_length = 0;
   self->start_address_i = 0;
   self->address_shift_i = 0;
   self->count_i = 0;

   DO_TRACE();

   self->clk_i = 1;
   DO_TRACE();

   self->clk_i = 0;
   self->run_i = 1;

   DO_TRACE();

   self->clk_i = 1;
 
   DO_TRACE();

   self->run_i = 0;
   self->databus_last = 0;

   self->clk_i = 0;
   DO_TRACE();

   // Maybe waiting for the databus is not needed.
   int loops = 0;
   int arrayIndex = 0;
   while(!self->doneAddress){
      while(!self->valid_o){
          UP();
          loops += 1;
          if(loops > 10000){
            PRINT("Failed on A\n");
            goto end;
          }
      }
      
      if(self->store_o){
        iptr addr = self->addr_o / 4; // DATA_W 
        //PRINT("%d\n",addr);
        seen[addr] = true;
      }

      UP();
   }

end:

   UP();
   UP();
   UP();
   UP();
   UP();

   int amountSeen = 0;
   for(int i = 0; i < result.amountOfExternalValuesRead; i++){
      if(seen[i]){
         amountSeen += 1;
      }
   }

   free(seen);
   result.amountOfInternalValuesUsed = amountSeen;

   return result;
}

int SimulateAddressGen(iptr* arrayToFill,int arraySize,AddressVArguments args){
   static VSuperAddress* self = nullptr;

   Verilated::traceEverOn(true);

   // Could also create and destroy everytime to make sure that we start fresh.
   if(self == nullptr){
      self = new VSuperAddress();
   }
   
   VerilatedVcdC* tfp = new VerilatedVcdC;
   self->trace(tfp, 99);
   tfp->open("simulate.vcd");

   bool doTrace = false;
   
#define DO_TRACE() self->eval(); \
   if(doTrace) {tfp->dump(contextp->time());} \
   contextp->timeInc(2);

#define UP() self->clk_i = 1; \
    DO_TRACE(); \
    self->clk_i = 0; \
    DO_TRACE();

   // These wires can always be set to these value.
   self->delay_i = 0;
   self->ignore_first_i = 0;
   self->data_ready_i = 1;
   self->data_valid_i = 1;
   self->reading = 1; // TODO: Does this make a difference? Also not like this existing in hardware either
   self->databus_ready = 1;
   self->ready_i = 1;

   self->run_i = 0;
   self->clk_i = 0;
   self->rst_i = 0;

   self->start_i = 0;
   self->duty_i = args.duty;
   self->per_i = args.per;
   self->incr_i = args.incr;
   self->iter_i = args.iter;
   self->shift_i = args.shift;
   self->per2_i = args.per2;
   self->incr2_i = args.incr2;
   self->iter2_i = args.iter2;
   self->shift2_i = args.shift2;
   self->per3_i = args.per3;
   self->incr3_i = args.incr3;
   self->iter3_i = args.iter3;
   self->shift3_i = args.shift3;

   self->databus_length = 0;
   self->start_address_i = 0;
   self->address_shift_i = 0;
   self->count_i = 0;

   DO_TRACE();

   self->clk_i = 1;
   DO_TRACE();

   self->clk_i = 0;
   self->run_i = 1;

   DO_TRACE();

   self->clk_i = 1;
 
   DO_TRACE();

   self->run_i = 0;
   self->databus_last = 0;

   self->clk_i = 0;
   DO_TRACE();

   // Maybe waiting for the databus is not needed.
   int loops = 0;
   int arrayIndex = 0;
   while(!self->doneAddress){
      while(!self->valid_o){
          UP();
          loops += 1;
          if(loops > 10000){
            PRINT("Failed on A\n");
            goto end;
          }
      }
      
      if(self->store_o){
        iptr addr = self->addr_o / 4; // DATA_W 
        if(arrayIndex < arraySize){
          arrayToFill[arrayIndex++] = SimulateAddressPosition(args.ext_addr,args.amount_minus_one,args.length,args.addr_shift,addr);
        }
      }

      UP();
   }

end:

   UP();
   UP();
   UP();
   UP();
   UP();

   return arrayIndex;
}

void SimulateAndPrintAddressGen(AddressVArguments args){
   static VSuperAddress* self = nullptr;

   Verilated::traceEverOn(true);

   // Could also create and destroy everytime to make sure that we start fresh.
   if(self == nullptr){
      self = new VSuperAddress();
   }
   
#ifdef TRACE_FST
   VerilatedFstC* tfp = new VerilatedFstC;
#else
   VerilatedVcdC* tfp = new VerilatedVcdC;
#endif

   self->trace(tfp, 99);
   tfp->open("simulate.vcd");

   bool doTrace = true;
   
#define DO_TRACE() self->eval(); \
   if(doTrace) {tfp->dump(contextp->time());} \
   contextp->timeInc(2);

#define UP() self->clk_i = 1; \
    DO_TRACE(); \
    self->clk_i = 0; \
    DO_TRACE();

   // These wires can always be set to these value.
   self->delay_i = 0;
   self->ignore_first_i = 0;
   self->data_ready_i = 1;
   self->data_valid_i = 1;
   self->reading = 1; // TODO: Does this make a difference? Also not like this existing in hardware either
   self->databus_ready = 1;
   self->ready_i = 1;

   self->run_i = 0;
   self->clk_i = 0;
   self->rst_i = 0;

   self->start_i = 0;
   self->duty_i = args.duty;
   self->per_i = args.per;
   self->incr_i = args.incr;
   self->iter_i = args.iter;
   self->shift_i = args.shift;
   self->per2_i = args.per2;
   self->incr2_i = args.incr2;
   self->iter2_i = args.iter2;
   self->shift2_i = args.shift2;
   self->per3_i = args.per3;
   self->incr3_i = args.incr3;
   self->iter3_i = args.iter3;
   self->shift3_i = args.shift3;

   self->databus_length = 0;
   self->start_address_i = 0;
   self->address_shift_i = 0;
   self->count_i = 0;

   DO_TRACE();

   self->clk_i = 1;
   DO_TRACE();

   self->clk_i = 0;
   self->run_i = 1;

   DO_TRACE();

   self->clk_i = 1;
 
   DO_TRACE();

   self->run_i = 0;
   self->databus_last = 0;

   self->clk_i = 0;
   DO_TRACE();

   // Maybe waiting for the databus is not needed.
   int loops = 0;
   int totalIndex = 0;
   PRINT("LoopIndex : Index of position being accessed\n");
   while(!self->doneAddress){
      while(!self->valid_o){
          UP();
          loops += 1;
          if(loops > 10000){
            PRINT("Failed on A\n");
            goto end;
          }
      }
      
      if(self->store_o){
        iptr addr = self->addr_o / 4; // DATA_W 
        iptr address = SimulateAddressPosition(args.ext_addr,args.amount_minus_one,args.length,args.addr_shift,addr);

        PRINT("%d : %ld\n",totalIndex++,(address - args.ext_addr) / 4);
      }

      UP();
   }

end:

   UP();
   UP();
   UP();
   UP();
   UP();

   tfp->close();
}

#undef UPDATE

struct VUnitInfo{
  const char* unitName;
  int mergeIndex;
  iptr ext_addr;
  iptr pingPong;
  iptr amount_minus_one;
  iptr length;
  iptr addr_shift;
  iptr enabled;
  iptr iter;
  iptr per;
  iptr duty;
  iptr start;
  iptr shift;
  iptr incr;
  iptr iter2;
  iptr per2;
  iptr shift2;
  iptr incr2;
  iptr iter3;
  iptr per3;
  iptr shift3;
  iptr incr3;
  iptr extra_delay;
  iptr ignore_first;
};

@{simulationStuff}


// ============================================================================
// Start of Versat public interface

#if 1
#include "versat_accel.h"

#ifdef __cplusplus
#include <cstdio>
#include <cstdlib>
#include <cstring>
#else
#define nullptr 0
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#endif

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

iptr versat_base;

#ifdef __cplusplus
extern "C"{
#endif

// Functions exported by wrapper that allow the accelerator to be simulated
int VersatAcceleratorCyclesElapsed();
void VersatReset();
void InitializeVerilator();
void VersatAcceleratorCreate();
void VersatAcceleratorSimulate();
void VersatSignalLoop();
int MemoryAccess(int address,int value,int write);

int GetAcceleratorCyclesElapsed();

#ifdef __cplusplus
  }
#endif

void ConfigEnableDMA(bool value){
}

void ConfigCreateVCD(bool value){
  CreateVCD = value;
}

void ConfigSimulateDatabus(bool value){
  SimulateDatabus = value;
}

void versat_init(int base){
  versatInitialized = true;
  CreateVCD = true;
  SimulateDatabus = true;
  versat_base = base;

  InitializeVerilator();
  VersatAcceleratorCreate();

  VersatLoadDelay(delayBuffer);
  
  accelStatic = &staticBuffer;
}

void SetVersatDebugPrintfFunction(VersatPrintf function){
  versatPrintf = function;
}

static void CheckVersatInitialized(){
  if(!versatInitialized){
    printf("Versat has not been initialized\n");
    fflush(stdout);
    exit(-1);
  }
}

void ResetAccelerator(){
  VersatReset();
  VersatLoadDelay(delayBuffer);
}

void SignalLoop(){
  VersatSignalLoop();
}

int GetAcceleratorCyclesElapsed(){
  return VersatAcceleratorCyclesElapsed();
}

void RunAccelerator(int times){
  CheckVersatInitialized();

  for(int i = 0; i < times; i++){
    VersatAcceleratorSimulate();
  }
}

void StartAccelerator(){
  CheckVersatInitialized();

  VersatAcceleratorSimulate();
}

void EndAccelerator(){
  // Do nothing. Start accelerator does everything, for now
}

void VersatMemoryCopy(volatile void* dest,volatile const void* data,int size){
  CheckVersatInitialized();

  char* byteViewDest = (char*) dest;
  char* configView = (char*) accelConfig;
  int* view = (int*) data;

  bool destInsideConfig = (byteViewDest >= configView && byteViewDest < configView + AcceleratorConfigSize);
  bool destEndOutsideConfig = destInsideConfig && (byteViewDest + size > configView + AcceleratorConfigSize);

  if(destEndOutsideConfig){
    printf("VersatMemoryCopy: Destination starts inside config and ends outside\n");
    printf("This is most likely an error, no transfer is being made\n");
    return;
  }
  
  if(destInsideConfig){
    memcpy((void*) dest,(void*) data,size);
  } else {
    for(int i = 0; i < (size / 4); i++){
      VersatUnitWrite(dest,i,view[i]);
    }
  }
}

void VersatUnitWrite(volatile const void* baseaddr,int index,int val){
  CheckVersatInitialized();

  iptr addr = (iptr) baseaddr + (index * sizeof(int)) - (versat_base + memMappedStart); // Convert back to zero based address
  MemoryAccess(addr,val,1);
}

int VersatUnitRead(volatile const void* baseaddr,int index){
  CheckVersatInitialized();

  iptr addr = (iptr) baseaddr + (index * sizeof(int)) - (versat_base + memMappedStart); // Convert back to zero based byte space address
  int res = MemoryAccess(addr,0,0);
  return res;
}

float VersatUnitReadFloat(volatile const void* base,int index){
  int res = VersatUnitRead(base,index);
  float* view = (float*) &res;
  return *view;
}

VersatDebugState VersatDebugGetState(){
  return (VersatDebugState){};
}

VersatProfile VersatProfileGet(){
  return (VersatProfile){};
}

void VersatPrintProfile(VersatProfile p){
}

void VersatProfileReset(){

}

#endif