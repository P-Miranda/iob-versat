#include "addressGen.hpp"

#include "memory.hpp"
#include "symbolic.hpp"
#include "utilsCore.hpp"

static String GetDefaultVarNameForLoop(int loopIndex,int amountOfLoops,bool fromInnermost){
  String vars[] = {
    STRING("x"),
    STRING("y"),
    STRING("z"),
    STRING("w"),
    STRING("a"),
    STRING("b"),
    STRING("c"),
    STRING("d"),
    STRING("e")
  };

  if(fromInnermost){
    loopIndex = amountOfLoops - loopIndex;
  }
    
  Assert(loopIndex >= 0);
  if(loopIndex > ARRAY_SIZE(vars)){
    printf("Error, either add more var names or put an hard cap on the amount of loops supported\n");
    Assert(false);
  }

  return vars[loopIndex];
}

Array<int> SimulateSingleAddressAccess(LoopLinearSum* access,Hashmap<String,int>* extraEnv,Arena* out){
  TEMP_REGION(temp,out);

  auto Recurse = [](auto Recurse,Hashmap<String,int>* env,GrowableArray<int>& values,LoopLinearSum* loops,SymbolicExpression* addr,int loopIndex) -> void{
    if(loopIndex < 0){
      int val = Evaluate(addr,env);
      *values.PushElem() = val;
    } else {
      LoopLinearSumTerm def = loops->terms[loopIndex];
      int loopStart = Evaluate(def.loopStart,env);
      int loopEnd = Evaluate(def.loopEnd,env);

      Assert(loopStart <= loopEnd);
      
      for(int i = loopStart; i < loopEnd; i++){
        env->Insert(def.var,i);

        Recurse(Recurse,env,values,loops,addr,loopIndex - 1);
      }
    }
  };

  Hashmap<String,int>* env = PushHashmap<String,int>(temp,access->terms.size + extraEnv->nodesUsed);

  for(auto p : extraEnv){
    env->Insert(p.first,*p.second);
  }

  GrowableArray<int> builder = StartArray<int>(out);
  SymbolicExpression* fullExpression = TransformIntoSymbolicExpression(access,temp);
  
  Recurse(Recurse,env,builder,access,fullExpression,access->terms.size - 1);
  Array<int> values = EndArray(builder);

  return values;
}

struct SimulateResult{
  Array<int> externalValues;
  Array<int> internalValues;
  Array<int> values;
};

SimulateResult SimulateAddressAccess(AddressAccess* access,Arena* out){
  TEMP_REGION(temp,out);

  Hashmap<String,int>* extraEnv = PushHashmap<String,int>(temp,access->inputVariableNames.size);
  for(String s : access->inputVariableNames){
    extraEnv->Insert(s,2);
  }
  
  Array<int> externalValues = SimulateSingleAddressAccess(access->external,extraEnv,out);
  Array<int> internalValues = SimulateSingleAddressAccess(access->internal,extraEnv,out);

  Array<int> result = PushArray<int>(out,internalValues.size);
  int inserted = 0;
  for(int index : internalValues){
    result[inserted++] = externalValues[index];
  }
  
  SimulateResult res = {};
  res.externalValues = externalValues;
  res.internalValues = internalValues;
  res.values = result;

  return res;
}

AddressAccess* CopyAddressAccess(AddressAccess* in,Arena* out){
  AddressAccess* res = PushStruct<AddressAccess>(out);

  res->external = Copy(in->external,out);
  res->internal = Copy(in->internal,out);
  res->inputVariableNames = CopyArray(in->inputVariableNames,out);

  return res;
}

SymbolicExpression* LoopMaximumValue(LoopLinearSumTerm term,Arena* out){
  TEMP_REGION(temp,out);
  
  SymbolicExpression* maxVal = SymbolicSub(term.loopEnd,PushLiteral(temp,1),temp);

  return Normalize(maxVal,out);
}

AddressAccess* RemoveConstantFromInnerLoop(AddressAccess* access,Arena* out){
  TEMP_REGION(temp,out);

  AddressAccess* result = CopyAddressAccess(access,out);

  int size = result->external->terms.size;
  SymbolicExpression* term = access->external->terms[0].term;
  
  if(!term){
    printf("Called remove constant from inner loop but access does not appear to have a constant on inner loop:\n");
    PrintAccess(result);
    DEBUG_BREAK();
  }

  if(term->type == SymbolicExpressionType_LITERAL && term->literal == 1 && !term->negative){
    return result;
  }
  
  if(term->type == SymbolicExpressionType_LITERAL){
    // New loop end is the maximum value generated by the innermost loop
    SymbolicExpression* end = result->external->terms[0].loopEnd;
    SymbolicExpression* one = PushLiteral(temp,1);
    SymbolicExpression* endMinusOne = SymbolicSub(end,one,temp);

    SymbolicExpression* newLoopEnd = SymbolicAdd(SymbolicMult(term,endMinusOne,temp),one,temp);

    result->external->terms[0].loopEnd = Normalize(newLoopEnd,out);
    result->external->terms[0].term = PushLiteral(out,1);

    SymbolicExpression* outerMostEnd = result->internal->terms[result->internal->terms.size - 1].loopEnd;
    
    SymbolicExpression* loopEnd = Normalize(SymbolicDiv(outerMostEnd,PushLiteral(temp,2),out),out);
    LoopLinearSum* newSumTerm = PushLoopLinearSumSimpleVar(STRING("y"),newLoopEnd,PushLiteral(out,0),loopEnd,out);
    
    result->internal->terms[0].term = SymbolicDeepCopy(term,out);
    result->internal->terms[0].loopEnd = PushLiteral(temp,2); // TODO: Need to see the logic for this one. Do not know if dividing by two is correct in the general case or only in the tests that we have been running.
    result->internal = AddLoopLinearSum(result->internal,newSumTerm,out);
  } else {
    NOT_IMPLEMENTED("yet");
  }
  
  return result;
}

// Actually, the second inner loop is "merged" with the first inner loop
AddressAccess* RemoveInnerLoop(AddressAccess* access,Arena* out){
  TEMP_REGION(temp,out);

  AddressAccess* result = CopyAddressAccess(access,out);

  int size = result->external->terms.size;
  
  // Not enough loops.
  if(size - 2 < 0){
    return result;
  }

  // Max value only taking into account outer loop.
  SymbolicExpression* constantTerm = result->external->terms[1].term;
  SymbolicExpression* maxLoop = LoopMaximumValue(result->external->terms[1],temp);
  SymbolicExpression* loopEndValue = result->external->terms[1].loopEnd;
  SymbolicExpression* maxOuterValue = Normalize(SymbolicMult(constantTerm,maxLoop,temp),temp);
  SymbolicExpression* maxInnerLoop = LoopMaximumValue(result->external->terms[0],temp);
  SymbolicExpression* maxValue = SymbolicAdd(maxOuterValue,maxInnerLoop,temp);
  SymbolicExpression* fixed = SymbolicAdd(maxValue,PushLiteral(out,1),temp);

  result->external = RemoveLoop(result->external,1,out);
  result->external->terms[0].loopEnd = Normalize(fixed,out);

  int lastTerm = result->internal->terms.size - 1;

  SymbolicExpression* originalLoopEnd = result->internal->terms[lastTerm].loopEnd;

  result->internal->terms[lastTerm].loopEnd = Normalize(loopEndValue,out);
  result->internal->terms[lastTerm].term = constantTerm;

  String varName = GetDefaultVarNameForLoop(result->internal->terms.size,0,false);
  SymbolicExpression* loopEnd = Normalize(SymbolicDiv(originalLoopEnd,loopEndValue,temp),out);
  
  LoopLinearSum* newLoop = PushLoopLinearSumSimpleVar(varName,fixed,PushLiteral(out,0),loopEnd,out);
  result->internal = AddLoopLinearSum(result->internal,newLoop,out);
  
  return result;
}

void PrintAccess(AddressAccess* access){
  TEMP_REGION(temp,nullptr);

  printf("External:\n");
  Print(access->external);
  printf("\nInternal:\n");
  Print(access->internal);
  printf("\n");
}

AddressAccess* ShiftExternalToInternal(AddressAccess* access,int maxLoopsTotal,int maxExternalLoops,Arena* out){
  TEMP_REGION(temp,out);

  PrintAccess(access);
  SimulateResult good = SimulateAddressAccess(access,temp);

  AddressAccess* result = RemoveConstantFromInnerLoop(access,out);

  PrintAccess(result);
  
  int loopIndex = 0;
  while(1){
    SimulateResult simulated = SimulateAddressAccess(result,temp);

    if(!Equal(simulated.values,good.values)){
      printf("Different on loopIndex: %d\n",loopIndex);
      PrintAccess(access);
      printf("Different from\n");
      PrintAccess(result);
      DEBUG_BREAK();
      Assert(false);
    } else {
      printf("OK\n");
    }

    if(result->external->terms.size <= maxExternalLoops){
      break;
    }
    
    result = RemoveInnerLoop(result,out);
    loopIndex += 1;
  } 
  
  PrintAccess(result);
  
  return result;
}

