Notes:

When converting the external into a 1 loop, the internal representation is just a copy of the external representation. At least when the address is always positive.

For the 3 loop case, if the constant is big enough, the 2 loop approach is worth it and it seems that we can figure out the values 

What I'm I doing in the 2 external loops approach?
I'm basically calculating the maximum value reacheable by the inner loops and then adding a new loop to the internal access that basically switches between each "transfer".

Because the transfers are always linear, if I divide an access into N tranfers, that means that the memory is divided into N regions.

For a 3 variable example, the Z variable controls which region we are reading from.

This appears to always work. However, if the constant associated to the outer external loop is small, we end up rereading the same values previously read.

What we are basically doing is collapsing the entire inner loops into a single loop that reads up to the maximum value of those inner loops. The logic for the inner loops is then moved directly into the internal address gen, except the outer loop which iterates the partitions created previously.

In order to do this however, we need to evaluate the inner loops because we need to calculate the maximum value reached by the inner loops in order to divide.

I think that the RemoveInnerLoop function does this. Except that, instead of doing everything in one go, we basically ignore the "remaining" outer loops and only perform 2 loops at a time.

The weirdness of this approach when we reach the iteration where external is going to end up with only 1 loop is then explained. The internal address generator is, at that point, already reading the values of N partitions (where the logic inside the partitions is exactly the same as the innermost logic of the original address generator). At this point, because the N partitions are not "linear", we basically lost the info required to generate the initial values and we are now trying to remove something that is not linea?. Not sure but it seems that, using the 2 loop approach and doing it iteratively is not ideal.

Good news. If we can evaluate the inner loops, we can perform the 2 loop approach everytime. The inner logic for the internal is just a copy from the initial access. The outermost loop of the internal requires loop evaluation. The innermost logic of the external requires outermost loop evaluation but the outermost does not.

What about loop optimizations?

If these can be done, they must be done before doing the conversion.

I'm just gonna start by creating a bunch of examples and see where it goes.

for z 0..2
for y 0..2
for x 0..2
addr = x + 5*y + 11*z

0,1,5,6,11,12,16,17

===== What I want: ===== 

== 2 External loops ==

External
for y 0..2
for x 0..7
addr = x + 11 * y

0,1,2,3,4,5,6,11,12,13,14,15,16,17

Internal
for z 0..2 (decider between the external loop y)
for y 0..2
for x 0..2
addr = x + 5*y + 7*z (z constant requires loop evaluation)

== Or 1 Loop: ==

External
for x 0..18
addr = x

Internal
for z 0..2
for y 0..2
for x 0..2
addr = x + 5*y + 11*z

===== What if z constant is small? ===== 

for z 0..2
for y 0..2
for x 0..2
addr = x + 5*y + 2*z

0,1,5,6,2,3,7,8

==== What I want: ====

== 2 Loops ==

External 
for y 0..2
for x 0..7
addr = x + 2*y

0,1,2,3,4,5,6
2,3,4,5,6,7,8

Internal
for z 0..2
for y 0..2
for x 0..2
addr = x + 5*y + 7*z

0,1,5,6,7,8,12,13

== 1 Loop ==

External 
for x 0..8
addr = x

Internal
for z 0..2
for y 0..2
for x 0..2
addr = x + 5*y + 2*z

===== What if y constant is small but z still big? ===== 

for z 0..2
for y 0..2
for x 0..2
addr = x + y + 11*z

0,1,1,2,11,12,12,13

== 1 Loop ==

External 
for x 0..14
addr = x

Internal
for z 0..2
for y 0..2
for x 0..2
addr = x + y + 11*z

== 2 Loop ==

External
for y 0..2
for x 0..3
addr = x + y*11

0,1,2,11,12,13

Internal
for z 0..2 (decider between the external loop y)
for y 0..2
for x 0..2
addr = x + y + 3*z ('z' constant requires loop evaluation)

==== What if we use different loop ranges? ====

for z 0..2
for y 0..2
for x 0..3
addr = x + 5*y + 11*z

0,1,2,5,6,7,11,12,13,16,17,18

== 2 External loops ==

External
for y 0..2
for x 0..8
addr = x + 11 * y

0,1,2,3,4,5,6,7,11,12,13,14,15,16,17,18

Internal
for z 0..2 (decider between the external loop y)
for y 0..2
for x 0..3
addr = x + 5*y + 8*z (z constant requires loop evaluation)

=== Different loop range for y ===

for z 0..2
for y 0..3
for x 0..2
addr = x + 5*y + 11*z

0,1,5,6,10,11,11,12,16,17,21,22

== 2 External loops ==

External
for y 0..3
for x 0..12
addr = x + 11 * y

0,1,2,3,4,5,6,7,8,9,10,11
11,12,13,14,15,16,17,18,19,20,21,22

Internal
for z 0..2 (decider between the external loop y)
for y 0..3
for x 0..2
addr = x + 5*y + 12*z (z constant requires loop evaluation)

0,1,5,6,10,11,12,13,17,18,22,23.

== What examples are missing? ==

Negative addresses? We could always shift things around so that everything lines up correctly.
Loops where the outermost constant is really small.

   Is there a way of rearranging things so that everything lines up correctly again while we minimize extra memory transfers?

      Me thinks it should be possible. If it would be possible to rearange loops, then we would be golden. All we would need to do is to rearange the largest loops upwards and everything would work fine.

== Exploring if it is possible to rearrange memory order to optimize transfers ==

Motivating simple example (2 loops given directly):

for y 0..3
for x 0..3
addr = 10*x + y

0,10,20,1,11,21,2,12,22

== Best possible ==

== 1 Loop ==

(1 Loop is always good for these examples because external always converts into one loop and internal gets all the logic)

External
for 0..23
addr = x

Internal
for y 0..3
for x 0..3
addr = 10*x + y

== 2 Loops ==

for y 0..3
for x 0..3
addr = x + 10*y

0,1,2,10,11,12,20,21,22

Internal
for y 0..3
for x 0..3
addr = 3*x + y

0,3,6,1,4,7,2,5,8 which is:

0,10,20,1,11,21,2,12,22

==== 3 Loop Example with innermost change needed ====

for z 0..2
for y 0..2
for x 0..2
addr = x * 10 + y + 100 * z

0,10,20,1,11,21,2,12,22,100,110,120,101,111,121,102,112,122

This example does not pose any problem because it's basically the loop collapse and internal logic transfer which basically solves the entire problem.

This means that the only case that matters is an innermost loop and a outermost loop interchange.

==== 3 Loop example with outermost change needed ====

for z 0..2
for y 0..2
for x 0..2
addr = x * 10 + y * 100 + z

0,10,100,110,1,11,101,111

Collapsing the loops directly would give us two transfers of 110 values.

Direct collapse would be:

External:
for y 0..2
for x 0..111
addr = x + y

0,1,...,110
1,2,...,111

Internal:
for z 0..2
for y 0..2
for x 0..2
addr = x * 10 + y * 100 + 111 * z

0,10,100,110,111,121,211,221,222.

This works but we are basically reading double the amount of values that are needed.

The best would be something like

External:
for y 0..2
for x 0..12
addr = x + 100 * y

0,1,2,3,4,5,6,7,8,9,10,11,100,101,102,103,104,105,106,107,108,109,110,111

Internal needs to produce:

0,10,12,22,1,11,13,23

Internal
for z 0..2
for y 0..2
for x 0..2
addr = 10*x + 12*y + z

0,10,12,22,1,11,13,23

It seems like the decision of wether to read from the next partition or not is now on the y loop. As if the y became the "outer" loop in terms of purpose

The logic for x appears to just follow directly. The logic for y looks to appear as if it was the collapse logic for z, but for y in this case. The logic for z is just a copy directly?

It appears that we are doing a direct copy, except that y is changed following the collapse logic. y is also the loop that contains the largest constant.

==== 3 Loop example with outermost change needed 2 ====

for z 0..2
for y 0..2
for x 0..2
addr = x * 100 + y * 10 + z

0,100,10,110,1,101,11,111

External:
fpr y 0..2
for x 0..12
addr = x + 100*y

0,1,2,3,4,5,6,7,8,9,10,11,100,101,102,103,104,105,106,107,108,109,110,111

Internal:
for z 0..2
for y 0..2
for x 0..2
addr = 12*x + 10*y + z

0,12,10,22,1,13,11,23.

It seems like the decision of reading from the next partition is now present on the x loop.

Can we find a way of "explaining" this approach?

It appears that it is a copy of internal logic, with the x loop, the one that contains the highest constant, having the constant replaced by the collapse logic value.

==== 4 Loop example with second outermost change needed ====

for w 0..2
for z 0..2
for y 0..2
for x 0..2
addr = 10 * x + 100 * y + z + 1000 * w

0,10,100,110,
1,11,101,111,
1000,1010,1100,1110,
1001,1011,1101,1111

External:
for y 0..2
for x 0..112
addr = x + 1000 * y

0,1,...,110,111,
1000,1001,...,1110,1111

Internal

for w 0..2
for z 0..2
for y 0..2
for x 0..2
addr = 10 * x + 100 * y + z + 112 * w

0,10,100,110,1,11,101,111,112,122,...

Everything is copied except the constant for the W loop. Which is replaced with the highest value possible of the remaining loops.
W is also the loop with the highest constant.
It makes sense that the highest constant is not copied, otherwise we would run out of memory space.


External:
for y 0..2
for x 0..a
2*x+5*y
Internal:
for x 0..2*a
x
After:
External:
for y 0..2
for x 0..2*a-1
x+5*y
Internal:
for y 0..2
for x 0..a
2*x+2*a*y+y
OK

for a == 5 it becomes:

Before:
External:
for y 0..2
for x 0..5
2*x+5*y
Internal:
for x 0..10
x

0,2,4,6,8,5,7,9,11,13


After:
External:
for y 0..2
for x 0..9
x+5*y

0,1,2,3,4,5,6,7,8,5,6,7,8,9,10,11,12,13

Internal:
for y 0..2
for x 0..5
2*x+9*y

0,2,4,6,8,9



for y 0..2
for x 0..100
addr = 2 * x + 5*y

0,2,4,198,5,7,9,...,203




